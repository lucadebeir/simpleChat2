import java.io.*;import common.ChatIF;import ocsf.server.*;/** * This class overrides some of the methods in the abstract superclass in order * to give more functionality to the server. * * @author Dr Timothy C. Lethbridge * @author Dr Robert Lagani&egrave;re * @author Fran&ccedil;ois B&eacute;langer * @author Paul Holden * @version July 2000 */public class EchoServer extends AbstractServer {	// Class variables *************************************************	/**	 * The default port to listen on.	 */	final public static int DEFAULT_PORT = 5555;		ChatIF serverUI;	// Constructors ****************************************************	/**	 * Constructs an instance of the echo server.	 *	 * @param port The port number to connect on.	 */	public EchoServer(int port, ChatIF serverUI) {		super(port);		this.serverUI = serverUI;		try {			this.listen();		} catch (IOException e) {			e.printStackTrace();		}	}	// Instance methods ************************************************	/**	 * This method handles any messages received from the client.	 *	 * @param msg    The message received from the client.	 * @param client The connection from which the message originated.	 */	public void handleMessageFromClient(Object msg, ConnectionToClient client) {		String[] args = ((String) msg).split(" ");		String command = args[0];		serverUI.display(command);				if( (boolean)client.getInfo("justMakeConnection") &&  !command.equals("#login")) {			try {				client.sendToClient("ERREUR | give our id before making command");				client.close();			} catch (IOException e) {				e.printStackTrace();			}		}		else {			switch (command) {			case "#quit":				try {					client.close();				} catch (IOException e) {					e.printStackTrace();				}				break;			case "#logoff":				try {					client.close();				} catch (IOException e) {					e.printStackTrace();				}				break;			case "#login" :				if ((boolean)client.getInfo("justMakeConnection")) {					serverUI.display(args[1]);					client.setInfo("id", args[1]);					serverUI.display("Client with id: " + client.getInfo("id"));					client.setInfo("justMakeConnection", false);				}				else {					try {						client.sendToClient("ERREUR | your already connected");					} catch (IOException e) {						e.printStackTrace();					}				}				break;			default:				serverUI.display("Message received: " + msg + " from " + client.getInfo("id"));				this.sendToAllClients(client.getInfo("id") + " - " + msg);			}		}	}			/**	 * This method handles any messages received from the server.	 *	 * @param msg    The message received from the server.	 */	public void handleMessageFromServerUI(Object msg) {		String[] args = ((String) msg).split(" ");		String command = args[0];		switch (command) {		case "#start":			if (this.isListening()) {				serverUI.display("server already started");			} else {				try {					this.listen(); // Start listening for connections				} catch (Exception ex) {					System.out.println("ERROR - Could not listen for clients!");				}			}			break;		case "#quit":			try {				this.close();				System.exit(0);			} catch (IOException e) {				e.printStackTrace();			}			break;		case "#stop":			this.stopListening();			break;		case "#close":			try {				this.sendToAllClients("#logoff");				this.close();			} catch (IOException e) {				// TODO Auto-generated catch block				e.printStackTrace();			}			break;		case "#setport":			if (this.isListening()) {				serverUI.display("Cannot set port if server is listening");			} else {				this.setPort(Integer.parseInt(args[1]));				serverUI.display("Port has been set to " + this.getPort());			}			break;		case "#getport":			serverUI.display("Your port is " + this.getPort());			break;		default:			serverUI.display(msg.toString());			this.sendToAllClients("server msg > " + msg);		}	}	/**	 * This method overrides the one in the superclass. Called when the server	 * starts listening for connections.	 */	protected void serverStarted() {		serverUI.display("Server listening for connections on port " + getPort());	}	/**	 * This method overrides the one in the superclass. Called when the server stops	 * listening for connections.	 */	protected void serverStopped() {		serverUI.display("Server has stopped listening for connections.");	}	// Hook methods ***************************************************	public void clientConnected(ConnectionToClient client) {		serverUI.display("A client is connected !");		client.setInfo("justMakeConnection", true);	}	synchronized public void clientDisconnected(ConnectionToClient client) {		serverUI.display("| SystemServer | --> a client closed his connection !");	}	synchronized protected void clientException(ConnectionToClient client, Throwable exception) {		serverUI.display("| SystemServer | --> a client is disconnected suddenly !");	}	// Class methods ***************************************************	/**	 * This method is responsible for the creation of the server instance (there is	 * no UI in this phase).	 *	 * @param args[0] The port number to listen on. Defaults to 5555 if no argument	 *                is entered.	 */	public static void main(String[] args) {		int port = 0; // Port to listen on		try {			port = Integer.parseInt(args[0]); // Get port from command line		} catch (Throwable t) {			port = DEFAULT_PORT; // Set port to 5555		}		EchoServer sv = new EchoServer(port, null);		try {			sv.listen(); // Start listening for connections		} catch (Exception ex) {			System.out.println("ERROR - Could not listen for clients!");		}	}}//End of EchoServer class